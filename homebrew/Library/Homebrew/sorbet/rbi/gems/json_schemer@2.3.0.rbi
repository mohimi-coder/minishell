# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `json_schemer` gem.
# Please instead update this file by running `bin/tapioca gem json_schemer`.


# Based on code from @robacarp found in issue 48:
# https://github.com/davishmcclurg/json_schemer/issues/48
#
# source://json_schemer//lib/json_schemer/version.rb#2
module JSONSchemer
  class << self
    # source://json_schemer//lib/json_schemer.rb#234
    def configuration; end

    # @yield [configuration]
    #
    # source://json_schemer//lib/json_schemer.rb#238
    def configure; end

    # source://json_schemer//lib/json_schemer.rb#142
    def draft201909; end

    # source://json_schemer//lib/json_schemer.rb#130
    def draft202012; end

    # source://json_schemer//lib/json_schemer.rb#178
    def draft4; end

    # source://json_schemer//lib/json_schemer.rb#166
    def draft6; end

    # source://json_schemer//lib/json_schemer.rb#154
    def draft7; end

    # source://json_schemer//lib/json_schemer.rb#230
    def openapi(document, **options); end

    # source://json_schemer//lib/json_schemer.rb#200
    def openapi30; end

    # source://json_schemer//lib/json_schemer.rb#222
    def openapi30_document; end

    # source://json_schemer//lib/json_schemer.rb#190
    def openapi31; end

    # source://json_schemer//lib/json_schemer.rb#214
    def openapi31_document; end

    # source://json_schemer//lib/json_schemer.rb#115
    def schema(schema, **options); end

    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer.rb#120
    def valid_schema?(schema, **options); end

    # source://json_schemer//lib/json_schemer.rb#125
    def validate_schema(schema, **options); end

    private

    # source://json_schemer//lib/json_schemer.rb#263
    def meta_schema(schema, options); end

    # source://json_schemer//lib/json_schemer.rb#244
    def resolve(schema, options); end
  end
end

# source://json_schemer//lib/json_schemer/result.rb#3
JSONSchemer::CATCHALL = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/result.rb#8
JSONSchemer::CLASSIC_ERROR_TYPES = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/cached_resolver.rb#15
class JSONSchemer::CachedRefResolver < ::JSONSchemer::CachedResolver; end

# source://json_schemer//lib/json_schemer/cached_resolver.rb#3
class JSONSchemer::CachedResolver
  # @return [CachedResolver] a new instance of CachedResolver
  #
  # source://json_schemer//lib/json_schemer/cached_resolver.rb#4
  def initialize(&resolver); end

  # source://json_schemer//lib/json_schemer/cached_resolver.rb#9
  def call(*args); end
end

# source://json_schemer//lib/json_schemer/configuration.rb#3
class JSONSchemer::Configuration < ::Struct
  # @return [Configuration] a new instance of Configuration
  #
  # source://json_schemer//lib/json_schemer/configuration.rb#9
  def initialize(base_uri: T.unsafe(nil), meta_schema: T.unsafe(nil), vocabulary: T.unsafe(nil), format: T.unsafe(nil), formats: T.unsafe(nil), content_encodings: T.unsafe(nil), content_media_types: T.unsafe(nil), keywords: T.unsafe(nil), before_property_validation: T.unsafe(nil), after_property_validation: T.unsafe(nil), insert_property_defaults: T.unsafe(nil), property_default_resolver: T.unsafe(nil), ref_resolver: T.unsafe(nil), regexp_resolver: T.unsafe(nil), output_format: T.unsafe(nil), resolve_enumerators: T.unsafe(nil), access_mode: T.unsafe(nil)); end

  # Returns the value of attribute access_mode
  #
  # @return [Object] the current value of access_mode
  def access_mode; end

  # Sets the attribute access_mode
  #
  # @param value [Object] the value to set the attribute access_mode to.
  # @return [Object] the newly set value
  def access_mode=(_); end

  # Returns the value of attribute after_property_validation
  #
  # @return [Object] the current value of after_property_validation
  def after_property_validation; end

  # Sets the attribute after_property_validation
  #
  # @param value [Object] the value to set the attribute after_property_validation to.
  # @return [Object] the newly set value
  def after_property_validation=(_); end

  # Returns the value of attribute base_uri
  #
  # @return [Object] the current value of base_uri
  def base_uri; end

  # Sets the attribute base_uri
  #
  # @param value [Object] the value to set the attribute base_uri to.
  # @return [Object] the newly set value
  def base_uri=(_); end

  # Returns the value of attribute before_property_validation
  #
  # @return [Object] the current value of before_property_validation
  def before_property_validation; end

  # Sets the attribute before_property_validation
  #
  # @param value [Object] the value to set the attribute before_property_validation to.
  # @return [Object] the newly set value
  def before_property_validation=(_); end

  # Returns the value of attribute content_encodings
  #
  # @return [Object] the current value of content_encodings
  def content_encodings; end

  # Sets the attribute content_encodings
  #
  # @param value [Object] the value to set the attribute content_encodings to.
  # @return [Object] the newly set value
  def content_encodings=(_); end

  # Returns the value of attribute content_media_types
  #
  # @return [Object] the current value of content_media_types
  def content_media_types; end

  # Sets the attribute content_media_types
  #
  # @param value [Object] the value to set the attribute content_media_types to.
  # @return [Object] the newly set value
  def content_media_types=(_); end

  # Returns the value of attribute format
  #
  # @return [Object] the current value of format
  def format; end

  # Sets the attribute format
  #
  # @param value [Object] the value to set the attribute format to.
  # @return [Object] the newly set value
  def format=(_); end

  # Returns the value of attribute formats
  #
  # @return [Object] the current value of formats
  def formats; end

  # Sets the attribute formats
  #
  # @param value [Object] the value to set the attribute formats to.
  # @return [Object] the newly set value
  def formats=(_); end

  # Returns the value of attribute insert_property_defaults
  #
  # @return [Object] the current value of insert_property_defaults
  def insert_property_defaults; end

  # Sets the attribute insert_property_defaults
  #
  # @param value [Object] the value to set the attribute insert_property_defaults to.
  # @return [Object] the newly set value
  def insert_property_defaults=(_); end

  # Returns the value of attribute keywords
  #
  # @return [Object] the current value of keywords
  def keywords; end

  # Sets the attribute keywords
  #
  # @param value [Object] the value to set the attribute keywords to.
  # @return [Object] the newly set value
  def keywords=(_); end

  # Returns the value of attribute meta_schema
  #
  # @return [Object] the current value of meta_schema
  def meta_schema; end

  # Sets the attribute meta_schema
  #
  # @param value [Object] the value to set the attribute meta_schema to.
  # @return [Object] the newly set value
  def meta_schema=(_); end

  # Returns the value of attribute output_format
  #
  # @return [Object] the current value of output_format
  def output_format; end

  # Sets the attribute output_format
  #
  # @param value [Object] the value to set the attribute output_format to.
  # @return [Object] the newly set value
  def output_format=(_); end

  # Returns the value of attribute property_default_resolver
  #
  # @return [Object] the current value of property_default_resolver
  def property_default_resolver; end

  # Sets the attribute property_default_resolver
  #
  # @param value [Object] the value to set the attribute property_default_resolver to.
  # @return [Object] the newly set value
  def property_default_resolver=(_); end

  # Returns the value of attribute ref_resolver
  #
  # @return [Object] the current value of ref_resolver
  def ref_resolver; end

  # Sets the attribute ref_resolver
  #
  # @param value [Object] the value to set the attribute ref_resolver to.
  # @return [Object] the newly set value
  def ref_resolver=(_); end

  # Returns the value of attribute regexp_resolver
  #
  # @return [Object] the current value of regexp_resolver
  def regexp_resolver; end

  # Sets the attribute regexp_resolver
  #
  # @param value [Object] the value to set the attribute regexp_resolver to.
  # @return [Object] the newly set value
  def regexp_resolver=(_); end

  # Returns the value of attribute resolve_enumerators
  #
  # @return [Object] the current value of resolve_enumerators
  def resolve_enumerators; end

  # Sets the attribute resolve_enumerators
  #
  # @param value [Object] the value to set the attribute resolve_enumerators to.
  # @return [Object] the newly set value
  def resolve_enumerators=(_); end

  # Returns the value of attribute vocabulary
  #
  # @return [Object] the current value of vocabulary
  def vocabulary; end

  # Sets the attribute vocabulary
  #
  # @param value [Object] the value to set the attribute vocabulary to.
  # @return [Object] the newly set value
  def vocabulary=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://json_schemer//lib/json_schemer/content.rb#3
module JSONSchemer::ContentEncoding; end

# source://json_schemer//lib/json_schemer/content.rb#4
JSONSchemer::ContentEncoding::BASE64 = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/content.rb#11
module JSONSchemer::ContentMediaType; end

# source://json_schemer//lib/json_schemer/content.rb#12
JSONSchemer::ContentMediaType::JSON = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#3
module JSONSchemer::Draft201909; end

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#4
JSONSchemer::Draft201909::BASE_URI = T.let(T.unsafe(nil), URI::HTTPS)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#6
JSONSchemer::Draft201909::CONTENT_ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#7
JSONSchemer::Draft201909::CONTENT_MEDIA_TYPES = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#5
JSONSchemer::Draft201909::FORMATS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#50
module JSONSchemer::Draft201909::Meta; end

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#105
JSONSchemer::Draft201909::Meta::APPLICATOR = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#297
JSONSchemer::Draft201909::Meta::CONTENT = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#51
JSONSchemer::Draft201909::Meta::CORE = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#286
JSONSchemer::Draft201909::Meta::FORMAT = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#253
JSONSchemer::Draft201909::Meta::META_DATA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#310
JSONSchemer::Draft201909::Meta::SCHEMAS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#158
JSONSchemer::Draft201909::Meta::VALIDATION = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/meta.rb#8
JSONSchemer::Draft201909::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#4
module JSONSchemer::Draft201909::Vocab; end

# source://json_schemer//lib/json_schemer/draft201909/vocab.rb#14
JSONSchemer::Draft201909::Vocab::APPLICATOR = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#5
module JSONSchemer::Draft201909::Vocab::Applicator; end

# source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#38
class JSONSchemer::Draft201909::Vocab::Applicator::AdditionalItems < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#39
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#43
  def parse; end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#47
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#6
class JSONSchemer::Draft201909::Vocab::Applicator::Items < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#7
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#11
  def parse; end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#21
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#61
class JSONSchemer::Draft201909::Vocab::Applicator::UnevaluatedItems < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#62
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#66
  def parse; end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#70
  def validate(instance, instance_location, keyword_location, context); end

  private

  # source://json_schemer//lib/json_schemer/draft201909/vocab/applicator.rb#88
  def collect_unevaluated_items(result, instance_location, unevaluated_items); end
end

# source://json_schemer//lib/json_schemer/draft201909/vocab.rb#27
JSONSchemer::Draft201909::Vocab::CONTENT = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/vocab.rb#5
JSONSchemer::Draft201909::Vocab::CORE = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#5
module JSONSchemer::Draft201909::Vocab::Core; end

# source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#6
class JSONSchemer::Draft201909::Vocab::Core::RecursiveAnchor < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#7
  def parse; end
end

# source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#13
class JSONSchemer::Draft201909::Vocab::Core::RecursiveRef < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#22
  def recursive_anchor; end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#18
  def ref_schema; end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#14
  def ref_uri; end

  # source://json_schemer//lib/json_schemer/draft201909/vocab/core.rb#27
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft201909/vocab.rb#26
JSONSchemer::Draft201909::Vocab::FORMAT = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/vocab.rb#28
JSONSchemer::Draft201909::Vocab::META_DATA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft201909/vocab.rb#25
JSONSchemer::Draft201909::Vocab::VALIDATION = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#3
module JSONSchemer::Draft202012; end

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#4
JSONSchemer::Draft202012::BASE_URI = T.let(T.unsafe(nil), URI::HTTPS)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#26
JSONSchemer::Draft202012::CONTENT_ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#29
JSONSchemer::Draft202012::CONTENT_MEDIA_TYPES = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#5
JSONSchemer::Draft202012::FORMATS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#90
module JSONSchemer::Draft202012::Meta; end

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#138
JSONSchemer::Draft202012::Meta::APPLICATOR = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#339
JSONSchemer::Draft202012::Meta::CONTENT = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#91
JSONSchemer::Draft202012::Meta::CORE = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#319
JSONSchemer::Draft202012::Meta::FORMAT_ANNOTATION = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#329
JSONSchemer::Draft202012::Meta::FORMAT_ASSERTION = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#287
JSONSchemer::Draft202012::Meta::META_DATA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#352
JSONSchemer::Draft202012::Meta::SCHEMAS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#182
JSONSchemer::Draft202012::Meta::UNEVALUATED = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#193
JSONSchemer::Draft202012::Meta::VALIDATION = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/meta.rb#32
JSONSchemer::Draft202012::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#4
module JSONSchemer::Draft202012::Vocab; end

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-01#section-10
#
# source://json_schemer//lib/json_schemer/draft202012/vocab.rb#24
JSONSchemer::Draft202012::Vocab::APPLICATOR = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#5
module JSONSchemer::Draft202012::Vocab::Applicator; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#297
class JSONSchemer::Draft202012::Vocab::Applicator::AdditionalProperties < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#298
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#302
  def false_schema_error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#306
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#310
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#6
class JSONSchemer::Draft202012::Vocab::Applicator::AllOf < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#7
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#11
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#17
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#25
class JSONSchemer::Draft202012::Vocab::Applicator::AnyOf < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#26
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#30
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#36
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#191
class JSONSchemer::Draft202012::Vocab::Applicator::Contains < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#192
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#196
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#200
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#349
class JSONSchemer::Draft202012::Vocab::Applicator::Dependencies < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#350
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#354
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#360
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#122
class JSONSchemer::Draft202012::Vocab::Applicator::DependentSchemas < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#123
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#127
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#133
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#106
class JSONSchemer::Draft202012::Vocab::Applicator::Else < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#107
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#111
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#115
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#79
class JSONSchemer::Draft202012::Vocab::Applicator::If < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#80
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#84
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#168
class JSONSchemer::Draft202012::Vocab::Applicator::Items < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#169
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#173
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#177
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#64
class JSONSchemer::Draft202012::Vocab::Applicator::Not < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#65
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#69
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#73
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#44
class JSONSchemer::Draft202012::Vocab::Applicator::OneOf < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#45
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#49
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#55
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#266
class JSONSchemer::Draft202012::Vocab::Applicator::PatternProperties < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#267
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#271
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#277
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#146
class JSONSchemer::Draft202012::Vocab::Applicator::PrefixItems < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#147
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#151
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#157
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#218
class JSONSchemer::Draft202012::Vocab::Applicator::Properties < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#219
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#223
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#229
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#329
class JSONSchemer::Draft202012::Vocab::Applicator::PropertyNames < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#330
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#334
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#338
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#90
class JSONSchemer::Draft202012::Vocab::Applicator::Then < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#91
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#95
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/applicator.rb#99
  def validate(instance, instance_location, keyword_location, context); end
end

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-8
#
# source://json_schemer//lib/json_schemer/draft202012/vocab.rb#88
JSONSchemer::Draft202012::Vocab::CONTENT = T.let(T.unsafe(nil), Hash)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-01#section-8
#
# source://json_schemer//lib/json_schemer/draft202012/vocab.rb#6
JSONSchemer::Draft202012::Vocab::CORE = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#5
module JSONSchemer::Draft202012::Vocab::Content; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#6
class JSONSchemer::Draft202012::Vocab::Content::ContentEncoding < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#7
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#11
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#20
class JSONSchemer::Draft202012::Vocab::Content::ContentMediaType < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#21
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#25
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#35
class JSONSchemer::Draft202012::Vocab::Content::ContentSchema < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#36
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/content.rb#40
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#5
module JSONSchemer::Draft202012::Vocab::Core; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#45
class JSONSchemer::Draft202012::Vocab::Core::Anchor < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#46
  def parse; end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#120
class JSONSchemer::Draft202012::Vocab::Core::Comment < ::JSONSchemer::Keyword; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#112
class JSONSchemer::Draft202012::Vocab::Core::Defs < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#113
  def parse; end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#71
class JSONSchemer::Draft202012::Vocab::Core::DynamicAnchor < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#72
  def parse; end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#80
class JSONSchemer::Draft202012::Vocab::Core::DynamicRef < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#89
  def dynamic_anchor; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#85
  def ref_schema; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#81
  def ref_uri; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#95
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#36
class JSONSchemer::Draft202012::Vocab::Core::Id < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#37
  def parse; end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#53
class JSONSchemer::Draft202012::Vocab::Core::Ref < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#62
  def ref_schema; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#58
  def ref_uri; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#66
  def validate(instance, instance_location, keyword_location, context); end

  class << self
    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#54
    def exclusive?; end
  end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#6
class JSONSchemer::Draft202012::Vocab::Core::Schema < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#7
  def parse; end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#128
class JSONSchemer::Draft202012::Vocab::Core::UnknownKeyword < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#139
  def fetch(token); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#129
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#149
  def parsed_schema; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#153
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#17
class JSONSchemer::Draft202012::Vocab::Core::Vocabulary < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#18
  def parse; end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#122
class JSONSchemer::Draft202012::Vocab::Core::XError < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/core.rb#123
  def message(error_key); end
end

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.2.1
#
# source://json_schemer//lib/json_schemer/draft202012/vocab.rb#80
JSONSchemer::Draft202012::Vocab::FORMAT_ANNOTATION = T.let(T.unsafe(nil), Hash)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.2.2
#
# source://json_schemer//lib/json_schemer/draft202012/vocab.rb#84
JSONSchemer::Draft202012::Vocab::FORMAT_ASSERTION = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/vocab/format_annotation.rb#5
module JSONSchemer::Draft202012::Vocab::FormatAnnotation; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/format_annotation.rb#6
class JSONSchemer::Draft202012::Vocab::FormatAnnotation::Format < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/format_annotation.rb#7
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/format_annotation.rb#11
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/format_annotation.rb#15
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/format_assertion.rb#5
module JSONSchemer::Draft202012::Vocab::FormatAssertion; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/format_assertion.rb#6
class JSONSchemer::Draft202012::Vocab::FormatAssertion::Format < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/format_assertion.rb#7
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/format_assertion.rb#11
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/format_assertion.rb#15
  def validate(instance, instance_location, keyword_location, _context); end
end

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-9
#
# source://json_schemer//lib/json_schemer/draft202012/vocab.rb#94
JSONSchemer::Draft202012::Vocab::META_DATA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/vocab/meta_data.rb#5
module JSONSchemer::Draft202012::Vocab::MetaData; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/meta_data.rb#6
class JSONSchemer::Draft202012::Vocab::MetaData::ReadOnly < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/meta_data.rb#7
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/meta_data.rb#11
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/meta_data.rb#17
class JSONSchemer::Draft202012::Vocab::MetaData::WriteOnly < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/meta_data.rb#18
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/meta_data.rb#22
  def validate(instance, instance_location, keyword_location, context); end
end

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-01#section-11
#
# source://json_schemer//lib/json_schemer/draft202012/vocab.rb#47
JSONSchemer::Draft202012::Vocab::UNEVALUATED = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#5
module JSONSchemer::Draft202012::Vocab::Unevaluated; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#6
class JSONSchemer::Draft202012::Vocab::Unevaluated::UnevaluatedItems < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#7
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#11
  def false_schema_error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#15
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#19
  def validate(instance, instance_location, keyword_location, context); end

  private

  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#37
  def collect_unevaluated_items(result, unevaluated_items); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#54
class JSONSchemer::Draft202012::Vocab::Unevaluated::UnevaluatedProperties < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#55
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#59
  def false_schema_error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#63
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#67
  def validate(instance, instance_location, keyword_location, context); end

  private

  # source://json_schemer//lib/json_schemer/draft202012/vocab/unevaluated.rb#89
  def collect_evaluated_keys(result, evaluated_keys); end
end

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-6
#
# source://json_schemer//lib/json_schemer/draft202012/vocab.rb#52
JSONSchemer::Draft202012::Vocab::VALIDATION = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#5
module JSONSchemer::Draft202012::Vocab::Validation; end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#71
class JSONSchemer::Draft202012::Vocab::Validation::Const < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#72
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#76
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#264
class JSONSchemer::Draft202012::Vocab::Validation::DependentRequired < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#265
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#269
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#61
class JSONSchemer::Draft202012::Vocab::Validation::Enum < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#62
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#66
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#101
class JSONSchemer::Draft202012::Vocab::Validation::ExclusiveMaximum < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#102
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#106
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#121
class JSONSchemer::Draft202012::Vocab::Validation::ExclusiveMinimum < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#122
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#126
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#195
class JSONSchemer::Draft202012::Vocab::Validation::MaxContains < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#196
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#200
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#165
class JSONSchemer::Draft202012::Vocab::Validation::MaxItems < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#166
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#170
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#131
class JSONSchemer::Draft202012::Vocab::Validation::MaxLength < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#132
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#136
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#219
class JSONSchemer::Draft202012::Vocab::Validation::MaxProperties < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#220
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#224
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#91
class JSONSchemer::Draft202012::Vocab::Validation::Maximum < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#92
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#96
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#207
class JSONSchemer::Draft202012::Vocab::Validation::MinContains < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#208
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#212
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#175
class JSONSchemer::Draft202012::Vocab::Validation::MinItems < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#176
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#180
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#141
class JSONSchemer::Draft202012::Vocab::Validation::MinLength < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#142
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#146
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#229
class JSONSchemer::Draft202012::Vocab::Validation::MinProperties < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#230
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#234
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#111
class JSONSchemer::Draft202012::Vocab::Validation::Minimum < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#112
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#116
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#81
class JSONSchemer::Draft202012::Vocab::Validation::MultipleOf < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#82
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#86
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#151
class JSONSchemer::Draft202012::Vocab::Validation::Pattern < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#152
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#156
  def parse; end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#160
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#239
class JSONSchemer::Draft202012::Vocab::Validation::Required < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#240
  def error(formatted_instance_location:, details:, **_arg2); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#244
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#6
class JSONSchemer::Draft202012::Vocab::Validation::Type < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#7
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#28
  def validate(instance, instance_location, keyword_location, _context); end

  private

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#39
  def valid_type(type, instance); end
end

# source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#185
class JSONSchemer::Draft202012::Vocab::Validation::UniqueItems < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#186
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft202012/vocab/validation.rb#190
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft4/meta.rb#3
module JSONSchemer::Draft4; end

# source://json_schemer//lib/json_schemer/draft4/meta.rb#4
JSONSchemer::Draft4::BASE_URI = T.let(T.unsafe(nil), URI::HTTP)

# source://json_schemer//lib/json_schemer/draft4/meta.rb#9
JSONSchemer::Draft4::CONTENT_ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft4/meta.rb#10
JSONSchemer::Draft4::CONTENT_MEDIA_TYPES = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft4/meta.rb#5
JSONSchemer::Draft4::FORMATS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft4/meta.rb#11
JSONSchemer::Draft4::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#4
module JSONSchemer::Draft4::Vocab; end

# source://json_schemer//lib/json_schemer/draft4/vocab.rb#5
JSONSchemer::Draft4::Vocab::ALL = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#5
module JSONSchemer::Draft4::Vocab::Validation; end

# source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#13
class JSONSchemer::Draft4::Vocab::Validation::ExclusiveMaximum < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#14
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#18
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#25
class JSONSchemer::Draft4::Vocab::Validation::ExclusiveMinimum < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#26
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#30
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#6
class JSONSchemer::Draft4::Vocab::Validation::Type < ::JSONSchemer::Draft202012::Vocab::Validation::Type
  private

  # source://json_schemer//lib/json_schemer/draft4/vocab/validation.rb#8
  def valid_type(type, instance); end
end

# source://json_schemer//lib/json_schemer/draft6/meta.rb#3
module JSONSchemer::Draft6; end

# source://json_schemer//lib/json_schemer/draft6/meta.rb#4
JSONSchemer::Draft6::BASE_URI = T.let(T.unsafe(nil), URI::HTTP)

# source://json_schemer//lib/json_schemer/draft6/meta.rb#14
JSONSchemer::Draft6::CONTENT_ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft6/meta.rb#15
JSONSchemer::Draft6::CONTENT_MEDIA_TYPES = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft6/meta.rb#5
JSONSchemer::Draft6::FORMATS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft6/meta.rb#16
JSONSchemer::Draft6::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft6/vocab.rb#4
module JSONSchemer::Draft6::Vocab; end

# source://json_schemer//lib/json_schemer/draft6/vocab.rb#5
JSONSchemer::Draft6::Vocab::ALL = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft7/meta.rb#3
module JSONSchemer::Draft7; end

# source://json_schemer//lib/json_schemer/draft7/meta.rb#4
JSONSchemer::Draft7::BASE_URI = T.let(T.unsafe(nil), URI::HTTP)

# source://json_schemer//lib/json_schemer/draft7/meta.rb#8
JSONSchemer::Draft7::CONTENT_ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft7/meta.rb#9
JSONSchemer::Draft7::CONTENT_MEDIA_TYPES = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft7/meta.rb#5
JSONSchemer::Draft7::FORMATS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft7/meta.rb#10
JSONSchemer::Draft7::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#4
module JSONSchemer::Draft7::Vocab; end

# source://json_schemer//lib/json_schemer/draft7/vocab.rb#5
JSONSchemer::Draft7::Vocab::ALL = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#5
module JSONSchemer::Draft7::Vocab::Validation; end

# source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#12
class JSONSchemer::Draft7::Vocab::Validation::AdditionalItems < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#13
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#17
  def parse; end

  # source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#21
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#38
class JSONSchemer::Draft7::Vocab::Validation::ContentEncoding < ::JSONSchemer::Draft202012::Vocab::Content::ContentEncoding
  # source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#39
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#43
  def validate(instance, instance_location, keyword_location, _context); end
end

# source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#52
class JSONSchemer::Draft7::Vocab::Validation::ContentMediaType < ::JSONSchemer::Draft202012::Vocab::Content::ContentMediaType
  # source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#53
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#57
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#6
class JSONSchemer::Draft7::Vocab::Validation::Ref < ::JSONSchemer::Draft202012::Vocab::Core::Ref
  class << self
    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer/draft7/vocab/validation.rb#7
    def exclusive?; end
  end
end

# source://json_schemer//lib/json_schemer/ecma_regexp.rb#3
class JSONSchemer::EcmaRegexp
  class << self
    # source://json_schemer//lib/json_schemer/ecma_regexp.rb#39
    def ruby_equivalent(pattern); end
  end
end

# source://json_schemer//lib/json_schemer/ecma_regexp.rb#27
JSONSchemer::EcmaRegexp::RUBY_EQUIVALENTS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/ecma_regexp.rb#4
class JSONSchemer::EcmaRegexp::Syntax < ::Regexp::Syntax::Base; end

# regexp_parser >= 2.3.0 uses syntax classes directly instead of instances
# :nocov:
#
# source://json_schemer//lib/json_schemer/ecma_regexp.rb#7
JSONSchemer::EcmaRegexp::Syntax::SYNTAX = JSONSchemer::EcmaRegexp::Syntax

# source://json_schemer//lib/json_schemer/errors.rb#6
module JSONSchemer::Errors
  class << self
    # source://json_schemer//lib/json_schemer/errors.rb#8
    def pretty(error); end
  end
end

# source://json_schemer//lib/json_schemer.rb#106
JSONSchemer::FILE_URI_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format/duration.rb#3
module JSONSchemer::Format
  extend ::JSONSchemer::Format::Duration
  extend ::JSONSchemer::Format::Email
  extend ::JSONSchemer::Format::Hostname
  extend ::JSONSchemer::Format::JSONPointer
  extend ::JSONSchemer::Format::URITemplate

  class << self
    # source://json_schemer//lib/json_schemer/format.rb#132
    def iri_escape(data); end

    # @raise [::URI::InvalidURIError]
    #
    # source://json_schemer//lib/json_schemer/format.rb#112
    def parse_uri_scheme(data); end

    # source://json_schemer//lib/json_schemer/format.rb#90
    def percent_encode(data, regexp); end

    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer/format.rb#96
    def valid_date_time?(data); end

    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer/format.rb#105
    def valid_ip?(data, family); end

    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer/format.rb#136
    def valid_regex?(data); end

    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer/format.rb#119
    def valid_uri?(data); end

    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer/format.rb#125
    def valid_uri_reference?(data); end

    # @return [Boolean]
    #
    # source://json_schemer//lib/json_schemer/format.rb#142
    def valid_uuid?(data); end
  end
end

# source://json_schemer//lib/json_schemer/format.rb#79
JSONSchemer::Format::BINARY_TO_PERCENT_ENCODED = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/format.rb#8
JSONSchemer::Format::DATE = T.let(T.unsafe(nil), Proc)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.3
#
# source://json_schemer//lib/json_schemer/format.rb#5
JSONSchemer::Format::DATE_TIME = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#70
JSONSchemer::Format::DATE_TIME_OFFSET_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#71
JSONSchemer::Format::DATE_TIME_SEPARATOR_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format.rb#14
JSONSchemer::Format::DURATION = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format/duration.rb#4
module JSONSchemer::Format::Duration
  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/duration.rb#18
  def valid_duration?(data); end
end

# duration          = "P" (dur-date / dur-time / dur-week)
#
# source://json_schemer//lib/json_schemer/format/duration.rb#15
JSONSchemer::Format::Duration::DURATION = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/duration.rb#16
JSONSchemer::Format::Duration::DURATION_REGEX = T.let(T.unsafe(nil), Regexp)

# dur-date          = (dur-day / dur-month / dur-year) [dur-time]
#
# source://json_schemer//lib/json_schemer/format/duration.rb#14
JSONSchemer::Format::Duration::DUR_DATE = T.let(T.unsafe(nil), String)

# dur-day           = 1*DIGIT "D"
#
# source://json_schemer//lib/json_schemer/format/duration.rb#10
JSONSchemer::Format::Duration::DUR_DAY = T.let(T.unsafe(nil), String)

# dur-hour          = 1*DIGIT "H" [dur-minute]
#
# source://json_schemer//lib/json_schemer/format/duration.rb#8
JSONSchemer::Format::Duration::DUR_HOUR = T.let(T.unsafe(nil), String)

# dur-second        = 1*DIGIT "S"
#
# source://json_schemer//lib/json_schemer/format/duration.rb#7
JSONSchemer::Format::Duration::DUR_MINUTE = T.let(T.unsafe(nil), String)

# dur-month         = 1*DIGIT "M" [dur-day]
#
# source://json_schemer//lib/json_schemer/format/duration.rb#12
JSONSchemer::Format::Duration::DUR_MONTH = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc3339#appendix-A
#
# source://json_schemer//lib/json_schemer/format/duration.rb#6
JSONSchemer::Format::Duration::DUR_SECOND = T.let(T.unsafe(nil), String)

# dur-time          = "T" (dur-hour / dur-minute / dur-second)
#
# source://json_schemer//lib/json_schemer/format/duration.rb#9
JSONSchemer::Format::Duration::DUR_TIME = T.let(T.unsafe(nil), String)

# dur-week          = 1*DIGIT "W"
#
# source://json_schemer//lib/json_schemer/format/duration.rb#11
JSONSchemer::Format::Duration::DUR_WEEK = T.let(T.unsafe(nil), String)

# dur-year          = 1*DIGIT "Y" [dur-month]
#
# source://json_schemer//lib/json_schemer/format/duration.rb#13
JSONSchemer::Format::Duration::DUR_YEAR = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.3.2
#
# source://json_schemer//lib/json_schemer/format.rb#18
JSONSchemer::Format::EMAIL = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format/email.rb#4
module JSONSchemer::Format::Email
  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/email.rb#44
  def valid_email?(data); end
end

# using `valid_id?` to check ip addresses because it's complicated.     # IPv6-address-literal  = "IPv6:" IPv6-addr
#
# source://json_schemer//lib/json_schemer/format/email.rb#36
JSONSchemer::Format::Email::ADDRESS_LITERAL = T.let(T.unsafe(nil), String)

# Atom            = 1*atext
#
# source://json_schemer//lib/json_schemer/format/email.rb#30
JSONSchemer::Format::Email::ATOM = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2
#
# source://json_schemer//lib/json_schemer/format/email.rb#9
JSONSchemer::Format::Email::A_TEXT = T.let(T.unsafe(nil), String)

# Dot-string      = Atom *("."  Atom)
#
# source://json_schemer//lib/json_schemer/format/email.rb#31
JSONSchemer::Format::Email::DOT_STRING = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/email.rb#42
JSONSchemer::Format::Email::EMAIL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/email.rb#32
JSONSchemer::Format::Email::LOCAL_PART = T.let(T.unsafe(nil), String)

# using `valid_hostname?` to check domain because it's complicated
#
# source://json_schemer//lib/json_schemer/format/email.rb#41
JSONSchemer::Format::Email::MAILBOX = T.let(T.unsafe(nil), String)

# qtextSMTP       = %d32-33 / %d35-91 / %d93-126
#                 ; i.e., within a quoted string, any
#                 ; ASCII graphic or space is permitted
#                 ; without blackslash-quoting except
#                 ; double-quote and the backslash itself.
#
# source://json_schemer//lib/json_schemer/format/email.rb#25
JSONSchemer::Format::Email::QUOTED_PAIR_SMTP = T.let(T.unsafe(nil), String)

# Quoted-string   = DQUOTE *QcontentSMTP DQUOTE
#
# source://json_schemer//lib/json_schemer/format/email.rb#29
JSONSchemer::Format::Email::QUOTED_STRING = T.let(T.unsafe(nil), String)

# quoted-pairSMTP = %d92 %d32-126
#                 ; i.e., backslash followed by any ASCII
#                 ; graphic (including itself) or SPace
#
# source://json_schemer//lib/json_schemer/format/email.rb#28
JSONSchemer::Format::Email::Q_CONTENT_SMTP = T.let(T.unsafe(nil), String)

# atext           = ALPHA / DIGIT /    ; Printable US-ASCII
#                   "!" / "#" /        ;  characters not including
#                   "$" / "%" /        ;  specials.  Used for atoms.
#                   "&" / "'" /
#                   "*" / "+" /
#                   "-" / "/" /
#                   "=" / "?" /
#                   "^" / "_" /
#                   "`" / "{" /
#                   "|" / "}" /
#                   "~"
#
# source://json_schemer//lib/json_schemer/format/email.rb#20
JSONSchemer::Format::Email::Q_TEXT_SMTP = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc6531#section-3.3
# I think this is the same as "UTF8-non-ascii"? (https://datatracker.ietf.org/doc/html/rfc6532#section-3.1)
#
# source://json_schemer//lib/json_schemer/format/email.rb#7
JSONSchemer::Format::Email::UTF8_NON_ASCII = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.3.3
#
# source://json_schemer//lib/json_schemer/format.rb#25
JSONSchemer::Format::HOSTNAME = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#72
JSONSchemer::Format::HOUR_24_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/hostname.rb#4
module JSONSchemer::Format::Hostname
  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/hostname.rb#42
  def valid_hostname?(data); end
end

# source://json_schemer//lib/json_schemer/format/hostname.rb#40
JSONSchemer::Format::Hostname::ARABIC_EXTENDED_DIGITS_REGEX = T.let(T.unsafe(nil), Regexp)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.8
# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.9
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#39
JSONSchemer::Format::Hostname::ARABIC_INDIC_DIGITS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/hostname.rb#33
JSONSchemer::Format::Hostname::CONTEXT_REGEX = T.let(T.unsafe(nil), Regexp)

# \u{00DF}\u{03C2} covered by \p{Ll}
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#10
JSONSchemer::Format::Hostname::EXCEPTIONS_DISALLOWED = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#section-2.6
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#9
JSONSchemer::Format::Hostname::EXCEPTIONS_PVALID = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.4
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#29
JSONSchemer::Format::Hostname::GREEK_LOWER_NUMERAL_SIGN = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.5
# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.6
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#32
JSONSchemer::Format::Hostname::HEBREW_PUNCTUATION = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#15
JSONSchemer::Format::Hostname::HOSTNAME_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/hostname.rb#19
JSONSchemer::Format::Hostname::JOINING_TYPE_D_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#18
JSONSchemer::Format::Hostname::JOINING_TYPE_L_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#21
JSONSchemer::Format::Hostname::JOINING_TYPE_R_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#20
JSONSchemer::Format::Hostname::JOINING_TYPE_T_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#36
JSONSchemer::Format::Hostname::KATAKANA_MIDDLE_DOT_CONTEXT_REGEX = T.let(T.unsafe(nil), Regexp)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.7
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#35
JSONSchemer::Format::Hostname::KATAKANA_MIDDLE_DOT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/hostname.rb#11
JSONSchemer::Format::Hostname::LABEL_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#14
JSONSchemer::Format::Hostname::LABEL_REGEX_STRING = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5891#section-4.2.3.2
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#13
JSONSchemer::Format::Hostname::LEADING_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#7
JSONSchemer::Format::Hostname::LETTER_DIGITS = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#section-2.1
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#6
JSONSchemer::Format::Hostname::MARKS = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.3
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#27
JSONSchemer::Format::Hostname::MIDDLE_DOT = T.let(T.unsafe(nil), String)

# bin/hostname_character_classes
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#17
JSONSchemer::Format::Hostname::VIRAMA_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/hostname.rb#25
JSONSchemer::Format::Hostname::ZERO_WIDTH_NON_JOINER_JOINING_TYPE = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.1
# https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.2
#
# source://json_schemer//lib/json_schemer/format/hostname.rb#24
JSONSchemer::Format::Hostname::ZERO_WIDTH_VIRAMA = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format.rb#21
JSONSchemer::Format::IDN_EMAIL = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#28
JSONSchemer::Format::IDN_HOSTNAME = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#75
JSONSchemer::Format::INVALID_QUERY_REGEX = T.let(T.unsafe(nil), Regexp)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.3.4
#
# source://json_schemer//lib/json_schemer/format.rb#32
JSONSchemer::Format::IPV4 = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#35
JSONSchemer::Format::IPV6 = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#74
JSONSchemer::Format::IP_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#45
JSONSchemer::Format::IRI = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#76
JSONSchemer::Format::IRI_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#48
JSONSchemer::Format::IRI_REFERENCE = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format/json_pointer.rb#4
module JSONSchemer::Format::JSONPointer
  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/json_pointer.rb#9
  def valid_json_pointer?(data); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/json_pointer.rb#13
  def valid_relative_json_pointer?(data); end
end

# source://json_schemer//lib/json_schemer/format/json_pointer.rb#6
JSONSchemer::Format::JSONPointer::JSON_POINTER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format/json_pointer.rb#5
JSONSchemer::Format::JSONPointer::JSON_POINTER_REGEX_STRING = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/json_pointer.rb#7
JSONSchemer::Format::JSONPointer::RELATIVE_JSON_POINTER_REGEX = T.let(T.unsafe(nil), Regexp)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.3.7
#
# source://json_schemer//lib/json_schemer/format.rb#59
JSONSchemer::Format::JSON_POINTER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#73
JSONSchemer::Format::LEAP_SECOND_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/format.rb#78
JSONSchemer::Format::NIL_UUID = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.3.8
#
# source://json_schemer//lib/json_schemer/format.rb#66
JSONSchemer::Format::REGEX = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#62
JSONSchemer::Format::RELATIVE_JSON_POINTER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#11
JSONSchemer::Format::TIME = T.let(T.unsafe(nil), Proc)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.3.5
#
# source://json_schemer//lib/json_schemer/format.rb#39
JSONSchemer::Format::URI = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format/uri_template.rb#4
module JSONSchemer::Format::URITemplate
  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/format/uri_template.rb#29
  def valid_uri_template?(data); end
end

# pct-encoded     =  "%" HEXDIG HEXDIG
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#7
JSONSchemer::Format::URITemplate::EXPLODE = T.let(T.unsafe(nil), String)

# operator        =  op-level2 / op-level3 / op-reserve
# op-level2       =  "+" / "#"
# op-level3       =  "." / "/" / ";" / "?" / "&"
# op-reserve      =  "=" / "," / "!" / "@" / "|"
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#19
JSONSchemer::Format::URITemplate::EXPRESSION = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/uri_template.rb#20
JSONSchemer::Format::URITemplate::LITERALS = T.let(T.unsafe(nil), String)

# explode         =  "*"
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#8
JSONSchemer::Format::URITemplate::MAX_LENGTH = T.let(T.unsafe(nil), String)

# modifier-level4 =  prefix / explode
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#10
JSONSchemer::Format::URITemplate::MODIFIER_LEVEL4 = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/uri_template.rb#15
JSONSchemer::Format::URITemplate::OPERATOR = T.let(T.unsafe(nil), String)

# https://datatracker.ietf.org/doc/html/rfc6570
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#6
JSONSchemer::Format::URITemplate::PCT_ENCODED = T.let(T.unsafe(nil), String)

# max-length      =  %x31-39 0*3DIGIT   ; positive integer < 10000
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#9
JSONSchemer::Format::URITemplate::PREFIX = T.let(T.unsafe(nil), String)

# literals        =  %x21 / %x23-24 / %x26 / %x28-3B / %x3D / %x3F-5B
#                 /  %x5D / %x5F / %x61-7A / %x7E / ucschar / iprivate
#                 /  pct-encoded
#                      ; any Unicode character except: CTL, SP,
#                      ;  DQUOTE, "'", "%" (aside from pct-encoded),
#                      ;  "<", ">", "\", "^", "`", "{", "|", "}"
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#26
JSONSchemer::Format::URITemplate::URI_TEMPLATE = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format/uri_template.rb#27
JSONSchemer::Format::URITemplate::URI_TEMPLATE_REGEX = T.let(T.unsafe(nil), Regexp)

# varchar         =  ALPHA / DIGIT / "_" / pct-encoded
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#11
JSONSchemer::Format::URITemplate::VARCHAR = T.let(T.unsafe(nil), String)

# variable-list   =  varspec *( "," varspec )
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#14
JSONSchemer::Format::URITemplate::VARIABLE_LIST = T.let(T.unsafe(nil), String)

# varname         =  varchar *( ["."] varchar )
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#12
JSONSchemer::Format::URITemplate::VARNAME = T.let(T.unsafe(nil), String)

# varspec         =  varname [ modifier-level4 ]
#
# source://json_schemer//lib/json_schemer/format/uri_template.rb#13
JSONSchemer::Format::URITemplate::VARSPEC = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/format.rb#42
JSONSchemer::Format::URI_REFERENCE = T.let(T.unsafe(nil), Proc)

# https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01#section-7.3.6
#
# source://json_schemer//lib/json_schemer/format.rb#55
JSONSchemer::Format::URI_TEMPLATE = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#51
JSONSchemer::Format::UUID = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/format.rb#77
JSONSchemer::Format::UUID_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/result.rb#6
JSONSchemer::I18N_ERRORS_SCOPE = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer/result.rb#5
JSONSchemer::I18N_SCOPE = T.let(T.unsafe(nil), String)

# unit separator
#
# source://json_schemer//lib/json_schemer/result.rb#4
JSONSchemer::I18N_SEPARATOR = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer.rb#76
class JSONSchemer::InvalidEcmaRegexp < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#75
class JSONSchemer::InvalidFileURI < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#73
class JSONSchemer::InvalidRefPointer < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#72
class JSONSchemer::InvalidRefResolution < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#74
class JSONSchemer::InvalidRegexpResolution < ::StandardError; end

# source://json_schemer//lib/json_schemer/keyword.rb#3
class JSONSchemer::Keyword
  include ::JSONSchemer::Output

  # @return [Keyword] a new instance of Keyword
  #
  # source://json_schemer//lib/json_schemer/keyword.rb#8
  def initialize(value, parent, keyword, schema = T.unsafe(nil)); end

  # source://json_schemer//lib/json_schemer/keyword.rb#21
  def absolute_keyword_location; end

  # source://json_schemer//lib/json_schemer/keyword.rb#29
  def error_key; end

  # source://json_schemer//lib/json_schemer/keyword.rb#33
  def fetch(key); end

  # Returns the value of attribute parent.
  #
  # source://json_schemer//lib/json_schemer/keyword.rb#6
  def parent; end

  # Returns the value of attribute parsed.
  #
  # source://json_schemer//lib/json_schemer/keyword.rb#6
  def parsed; end

  # source://json_schemer//lib/json_schemer/keyword.rb#37
  def parsed_schema; end

  # Returns the value of attribute root.
  #
  # source://json_schemer//lib/json_schemer/keyword.rb#6
  def root; end

  # source://json_schemer//lib/json_schemer/keyword.rb#25
  def schema_pointer; end

  # source://json_schemer//lib/json_schemer/keyword.rb#17
  def validate(_instance, _instance_location, _keyword_location, _context); end

  # Returns the value of attribute value.
  #
  # source://json_schemer//lib/json_schemer/keyword.rb#6
  def value; end

  private

  # source://json_schemer//lib/json_schemer/keyword.rb#43
  def parse; end

  # source://json_schemer//lib/json_schemer/keyword.rb#47
  def subschema(value, keyword = T.unsafe(nil), **options); end
end

# source://json_schemer//lib/json_schemer/location.rb#3
module JSONSchemer::Location
  class << self
    # source://json_schemer//lib/json_schemer/location.rb#20
    def escape_json_pointer_token(token); end

    # source://json_schemer//lib/json_schemer/location.rb#12
    def join(location, name); end

    # source://json_schemer//lib/json_schemer/location.rb#16
    def resolve(location); end

    # source://json_schemer//lib/json_schemer/location.rb#8
    def root; end
  end
end

# source://json_schemer//lib/json_schemer/location.rb#4
JSONSchemer::Location::JSON_POINTER_TOKEN_ESCAPE_CHARS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/location.rb#5
JSONSchemer::Location::JSON_POINTER_TOKEN_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer.rb#285
JSONSchemer::META_SCHEMAS_BY_BASE_URI_STR = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer.rb#273
JSONSchemer::META_SCHEMA_CALLABLES_BY_BASE_URI_STR = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi.rb#3
class JSONSchemer::OpenAPI
  # @return [OpenAPI] a new instance of OpenAPI
  #
  # source://json_schemer//lib/json_schemer/openapi.rb#4
  def initialize(document, **options); end

  # source://json_schemer//lib/json_schemer/openapi.rb#30
  def ref(value); end

  # source://json_schemer//lib/json_schemer/openapi.rb#34
  def schema(name); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/openapi.rb#22
  def valid?; end

  # source://json_schemer//lib/json_schemer/openapi.rb#26
  def validate(**options); end
end

# source://json_schemer//lib/json_schemer/openapi30/document.rb#3
module JSONSchemer::OpenAPI30; end

# source://json_schemer//lib/json_schemer/openapi30/meta.rb#4
JSONSchemer::OpenAPI30::BASE_URI = T.let(T.unsafe(nil), URI::Generic)

# source://json_schemer//lib/json_schemer/openapi30/document.rb#4
module JSONSchemer::OpenAPI30::Document; end

# source://json_schemer//lib/json_schemer/openapi30/document.rb#5
JSONSchemer::OpenAPI30::Document::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi30/document.rb#1667
JSONSchemer::OpenAPI30::Document::SCHEMAS = T.let(T.unsafe(nil), Hash)

# https://spec.openapis.org/oas/v3.0.3#data-types
#
# source://json_schemer//lib/json_schemer/openapi30/meta.rb#6
JSONSchemer::OpenAPI30::FORMATS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi30/meta.rb#25
module JSONSchemer::OpenAPI30::Meta; end

# source://json_schemer//lib/json_schemer/openapi30/meta.rb#26
JSONSchemer::OpenAPI30::Meta::SCHEMAS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi30/meta.rb#11
JSONSchemer::OpenAPI30::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi30/vocab/base.rb#4
module JSONSchemer::OpenAPI30::Vocab; end

# https://spec.openapis.org/oas/v3.0.3#schema-object
#
# source://json_schemer//lib/json_schemer/openapi30/vocab.rb#6
JSONSchemer::OpenAPI30::Vocab::BASE = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi30/vocab/base.rb#5
module JSONSchemer::OpenAPI30::Vocab::Base; end

# source://json_schemer//lib/json_schemer/openapi30/vocab/base.rb#6
class JSONSchemer::OpenAPI30::Vocab::Base::Type < ::JSONSchemer::Draft4::Vocab::Validation::Type
  # source://json_schemer//lib/json_schemer/openapi30/vocab/base.rb#7
  def parse; end
end

# source://json_schemer//lib/json_schemer/openapi31/meta.rb#3
module JSONSchemer::OpenAPI31; end

# source://json_schemer//lib/json_schemer/openapi31/meta.rb#4
JSONSchemer::OpenAPI31::BASE_URI = T.let(T.unsafe(nil), URI::HTTPS)

# source://json_schemer//lib/json_schemer/openapi31/document.rb#4
module JSONSchemer::OpenAPI31::Document
  class << self
    # source://json_schemer//lib/json_schemer/openapi31/document.rb#16
    def dialect_schema(dialect); end
  end
end

# source://json_schemer//lib/json_schemer/openapi31/document.rb#14
JSONSchemer::OpenAPI31::Document::DEFAULT_DIALECT = T.let(T.unsafe(nil), String)

# http://json-schema.org/blog/posts/validating-openapi-and-json-schema
#
# source://json_schemer//lib/json_schemer/openapi31/document.rb#6
JSONSchemer::OpenAPI31::Document::DIALECTS = T.let(T.unsafe(nil), Array)

# source://json_schemer//lib/json_schemer/openapi31/document.rb#14
JSONSchemer::OpenAPI31::Document::OTHER_DIALECTS = T.let(T.unsafe(nil), Array)

# source://json_schemer//lib/json_schemer/openapi31/document.rb#104
JSONSchemer::OpenAPI31::Document::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi31/document.rb#1543
JSONSchemer::OpenAPI31::Document::SCHEMAS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi31/document.rb#63
JSONSchemer::OpenAPI31::Document::SCHEMA_BASE = T.let(T.unsafe(nil), Hash)

# https://spec.openapis.org/oas/v3.1.0#data-types
#
# source://json_schemer//lib/json_schemer/openapi31/meta.rb#6
JSONSchemer::OpenAPI31::FORMATS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi31/meta.rb#40
module JSONSchemer::OpenAPI31::Meta; end

# source://json_schemer//lib/json_schemer/openapi31/meta.rb#41
JSONSchemer::OpenAPI31::Meta::BASE = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi31/meta.rb#130
JSONSchemer::OpenAPI31::Meta::SCHEMAS = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi31/meta.rb#13
JSONSchemer::OpenAPI31::SCHEMA = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#4
module JSONSchemer::OpenAPI31::Vocab; end

# https://spec.openapis.org/oas/latest.html#schema-object
#
# source://json_schemer//lib/json_schemer/openapi31/vocab.rb#6
JSONSchemer::OpenAPI31::Vocab::BASE = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#5
module JSONSchemer::OpenAPI31::Vocab::Base; end

# source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#6
class JSONSchemer::OpenAPI31::Vocab::Base::AllOf < ::JSONSchemer::Draft202012::Vocab::Applicator::AllOf
  # Returns the value of attribute skip_ref_once.
  #
  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#7
  def skip_ref_once; end

  # Sets the attribute skip_ref_once
  #
  # @param value the value to set the attribute skip_ref_once to.
  #
  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#7
  def skip_ref_once=(_arg0); end

  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#9
  def validate(instance, instance_location, keyword_location, context); end
end

# source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#24
class JSONSchemer::OpenAPI31::Vocab::Base::AnyOf < ::JSONSchemer::Draft202012::Vocab::Applicator::AnyOf
  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#25
  def validate(*_arg0); end
end

# source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#36
class JSONSchemer::OpenAPI31::Vocab::Base::Discriminator < ::JSONSchemer::Keyword
  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#42
  def error(formatted_instance_location:, **_arg1); end

  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#46
  def mapping; end

  # Returns the value of attribute skip_ref_once.
  #
  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#40
  def skip_ref_once; end

  # Sets the attribute skip_ref_once
  #
  # @param value the value to set the attribute skip_ref_once to.
  #
  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#40
  def skip_ref_once=(_arg0); end

  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#50
  def subschemas_by_property_value; end

  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#102
  def validate(instance, instance_location, keyword_location, context); end
end

# https://spec.openapis.org/oas/v3.1.0#components-object
#
# source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#38
JSONSchemer::OpenAPI31::Vocab::Base::Discriminator::FIXED_FIELD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#30
class JSONSchemer::OpenAPI31::Vocab::Base::OneOf < ::JSONSchemer::Draft202012::Vocab::Applicator::OneOf
  # source://json_schemer//lib/json_schemer/openapi31/vocab/base.rb#31
  def validate(*_arg0); end
end

# source://json_schemer//lib/json_schemer/output.rb#3
module JSONSchemer::Output
  # Returns the value of attribute keyword.
  #
  # source://json_schemer//lib/json_schemer/output.rb#6
  def keyword; end

  # Returns the value of attribute schema.
  #
  # source://json_schemer//lib/json_schemer/output.rb#6
  def schema; end

  # source://json_schemer//lib/json_schemer/output.rb#8
  def x_error; end

  private

  # :nocov:
  #
  # source://json_schemer//lib/json_schemer/output.rb#43
  def deep_stringify_keys(obj); end

  # source://json_schemer//lib/json_schemer/output.rb#19
  def escaped_keyword; end

  # source://json_schemer//lib/json_schemer/output.rb#27
  def fragment_encode(location); end

  # source://json_schemer//lib/json_schemer/output.rb#23
  def join_location(location, keyword); end

  # source://json_schemer//lib/json_schemer/output.rb#15
  def result(instance, instance_location, keyword_location, valid, nested = T.unsafe(nil), type: T.unsafe(nil), annotation: T.unsafe(nil), details: T.unsafe(nil), ignore_nested: T.unsafe(nil)); end

  # source://json_schemer//lib/json_schemer/output.rb#33
  def stringify(key); end
end

# source://json_schemer//lib/json_schemer/output.rb#4
JSONSchemer::Output::FRAGMENT_ENCODE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/result.rb#12
class JSONSchemer::Result < ::Struct
  # Returns the value of attribute annotation
  #
  # @return [Object] the current value of annotation
  def annotation; end

  # Sets the attribute annotation
  #
  # @param value [Object] the value to set the attribute annotation to.
  # @return [Object] the newly set value
  def annotation=(_); end

  # source://json_schemer//lib/json_schemer/result.rb#126
  def basic; end

  # source://json_schemer//lib/json_schemer/result.rb#173
  def classic; end

  # source://json_schemer//lib/json_schemer/result.rb#147
  def detailed; end

  # Returns the value of attribute details
  #
  # @return [Object] the current value of details
  def details; end

  # Sets the attribute details
  #
  # @param value [Object] the value to set the attribute details to.
  # @return [Object] the newly set value
  def details=(_); end

  # source://json_schemer//lib/json_schemer/result.rb#30
  def error; end

  # source://json_schemer//lib/json_schemer/result.rb#122
  def flag; end

  # source://json_schemer//lib/json_schemer/result.rb#62
  def i18n!; end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/result.rb#57
  def i18n?; end

  # Returns the value of attribute ignore_nested
  #
  # @return [Object] the current value of ignore_nested
  def ignore_nested; end

  # Sets the attribute ignore_nested
  #
  # @param value [Object] the value to set the attribute ignore_nested to.
  # @return [Object] the newly set value
  def ignore_nested=(_); end

  # source://json_schemer//lib/json_schemer/result.rb#192
  def insert_property_defaults(context); end

  # Returns the value of attribute instance
  #
  # @return [Object] the current value of instance
  def instance; end

  # Sets the attribute instance
  #
  # @param value [Object] the value to set the attribute instance to.
  # @return [Object] the newly set value
  def instance=(_); end

  # Returns the value of attribute instance_location
  #
  # @return [Object] the current value of instance_location
  def instance_location; end

  # Sets the attribute instance_location
  #
  # @param value [Object] the value to set the attribute instance_location to.
  # @return [Object] the newly set value
  def instance_location=(_); end

  # Returns the value of attribute keyword_location
  #
  # @return [Object] the current value of keyword_location
  def keyword_location; end

  # Sets the attribute keyword_location
  #
  # @param value [Object] the value to set the attribute keyword_location to.
  # @return [Object] the newly set value
  def keyword_location=(_); end

  # Returns the value of attribute nested
  #
  # @return [Object] the current value of nested
  def nested; end

  # Sets the attribute nested
  #
  # @param value [Object] the value to set the attribute nested to.
  # @return [Object] the newly set value
  def nested=(_); end

  # Returns the value of attribute nested_key
  #
  # @return [Object] the current value of nested_key
  def nested_key; end

  # Sets the attribute nested_key
  #
  # @param value [Object] the value to set the attribute nested_key to.
  # @return [Object] the newly set value
  def nested_key=(_); end

  # source://json_schemer//lib/json_schemer/result.rb#13
  def output(output_format); end

  # Returns the value of attribute source
  #
  # @return [Object] the current value of source
  def source; end

  # Sets the attribute source
  #
  # @param value [Object] the value to set the attribute source to.
  # @return [Object] the newly set value
  def source=(_); end

  # source://json_schemer//lib/json_schemer/result.rb#105
  def to_classic; end

  # source://json_schemer//lib/json_schemer/result.rb#88
  def to_output_unit; end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  # Returns the value of attribute valid
  #
  # @return [Object] the current value of valid
  def valid; end

  # Sets the attribute valid
  #
  # @param value [Object] the value to set the attribute valid to.
  # @return [Object] the newly set value
  def valid=(_); end

  # source://json_schemer//lib/json_schemer/result.rb#163
  def verbose; end

  private

  # source://json_schemer//lib/json_schemer/result.rb#232
  def default_keyword_instance(schema); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://json_schemer//lib/json_schemer/schema.rb#3
class JSONSchemer::Schema
  include ::JSONSchemer::Output

  # @return [Schema] a new instance of Schema
  #
  # source://json_schemer//lib/json_schemer/schema.rb#49
  def initialize(value, parent = T.unsafe(nil), root = T.unsafe(nil), keyword = T.unsafe(nil), configuration: T.unsafe(nil), base_uri: T.unsafe(nil), meta_schema: T.unsafe(nil), vocabulary: T.unsafe(nil), format: T.unsafe(nil), formats: T.unsafe(nil), content_encodings: T.unsafe(nil), content_media_types: T.unsafe(nil), keywords: T.unsafe(nil), before_property_validation: T.unsafe(nil), after_property_validation: T.unsafe(nil), insert_property_defaults: T.unsafe(nil), property_default_resolver: T.unsafe(nil), ref_resolver: T.unsafe(nil), regexp_resolver: T.unsafe(nil), output_format: T.unsafe(nil), resolve_enumerators: T.unsafe(nil), access_mode: T.unsafe(nil)); end

  # source://json_schemer//lib/json_schemer/schema.rb#267
  def absolute_keyword_location; end

  # Returns the value of attribute after_property_validation.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def after_property_validation; end

  # Returns the value of attribute base_uri.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#45
  def base_uri; end

  # Sets the attribute base_uri
  #
  # @param value the value to set the attribute base_uri to.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#45
  def base_uri=(_arg0); end

  # Returns the value of attribute before_property_validation.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def before_property_validation; end

  # source://json_schemer//lib/json_schemer/schema.rb#218
  def bundle; end

  # Returns the value of attribute configuration.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#46
  def configuration; end

  # Returns the value of attribute content_encodings.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def content_encodings; end

  # Returns the value of attribute content_media_types.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def content_media_types; end

  # Returns the value of attribute custom_keywords.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def custom_keywords; end

  # source://json_schemer//lib/json_schemer/schema.rb#326
  def defs_keyword; end

  # source://json_schemer//lib/json_schemer/schema.rb#334
  def error(formatted_instance_location:, **options); end

  # source://json_schemer//lib/json_schemer/schema.rb#290
  def error_key; end

  # source://json_schemer//lib/json_schemer/schema.rb#294
  def fetch(key); end

  # source://json_schemer//lib/json_schemer/schema.rb#306
  def fetch_content_encoding(content_encoding, *args, &block); end

  # source://json_schemer//lib/json_schemer/schema.rb#314
  def fetch_content_media_type(content_media_type, *args, &block); end

  # source://json_schemer//lib/json_schemer/schema.rb#298
  def fetch_format(format, *args, &block); end

  # Returns the value of attribute format.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def format; end

  # Returns the value of attribute formats.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def formats; end

  # source://json_schemer//lib/json_schemer/schema.rb#322
  def id_keyword; end

  # Returns the value of attribute insert_property_defaults.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def insert_property_defaults; end

  # source://json_schemer//lib/json_schemer/schema.rb#357
  def inspect; end

  # Returns the value of attribute keyword_order.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#45
  def keyword_order; end

  # Sets the attribute keyword_order
  #
  # @param value the value to set the attribute keyword_order to.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#45
  def keyword_order=(_arg0); end

  # Returns the value of attribute keywords.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#45
  def keywords; end

  # Sets the attribute keywords
  #
  # @param value the value to set the attribute keywords to.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#45
  def keywords=(_arg0); end

  # Returns the value of attribute meta_schema.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#45
  def meta_schema; end

  # Sets the attribute meta_schema
  #
  # @param value the value to set the attribute meta_schema to.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#45
  def meta_schema=(_arg0); end

  # Returns the value of attribute parent.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#46
  def parent; end

  # Returns the value of attribute parsed.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#46
  def parsed; end

  # source://json_schemer//lib/json_schemer/schema.rb#123
  def ref(value); end

  # source://json_schemer//lib/json_schemer/schema.rb#342
  def ref_resolver; end

  # source://json_schemer//lib/json_schemer/schema.rb#346
  def regexp_resolver; end

  # @raise [InvalidRefPointer]
  #
  # source://json_schemer//lib/json_schemer/schema.rb#170
  def resolve_ref(uri); end

  # source://json_schemer//lib/json_schemer/schema.rb#214
  def resolve_regexp(pattern); end

  # source://json_schemer//lib/json_schemer/schema.rb#330
  def resources; end

  # Returns the value of attribute root.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#46
  def root; end

  # source://json_schemer//lib/json_schemer/schema.rb#280
  def schema_pointer; end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema.rb#99
  def valid?(instance, **options); end

  # @return [Boolean]
  #
  # source://json_schemer//lib/json_schemer/schema.rb#115
  def valid_schema?(**options); end

  # source://json_schemer//lib/json_schemer/schema.rb#103
  def validate(instance, output_format: T.unsafe(nil), resolve_enumerators: T.unsafe(nil), access_mode: T.unsafe(nil)); end

  # source://json_schemer//lib/json_schemer/schema.rb#127
  def validate_instance(instance, instance_location, keyword_location, context); end

  # source://json_schemer//lib/json_schemer/schema.rb#119
  def validate_schema(**options); end

  # Returns the value of attribute value.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#46
  def value; end

  # Returns the value of attribute vocabulary.
  #
  # source://json_schemer//lib/json_schemer/schema.rb#47
  def vocabulary; end

  private

  # source://json_schemer//lib/json_schemer/schema.rb#363
  def parse; end

  # source://json_schemer//lib/json_schemer/schema.rb#409
  def property_default_resolver; end

  # source://json_schemer//lib/json_schemer/schema.rb#413
  def resolve_enumerators!(output); end

  # source://json_schemer//lib/json_schemer/schema.rb#405
  def root_keyword_location; end
end

# source://json_schemer//lib/json_schemer/schema.rb#4
class JSONSchemer::Schema::Context < ::Struct
  # Returns the value of attribute access_mode
  #
  # @return [Object] the current value of access_mode
  def access_mode; end

  # Sets the attribute access_mode
  #
  # @param value [Object] the value to set the attribute access_mode to.
  # @return [Object] the newly set value
  def access_mode=(_); end

  # Returns the value of attribute adjacent_results
  #
  # @return [Object] the current value of adjacent_results
  def adjacent_results; end

  # Sets the attribute adjacent_results
  #
  # @param value [Object] the value to set the attribute adjacent_results to.
  # @return [Object] the newly set value
  def adjacent_results=(_); end

  # Returns the value of attribute dynamic_scope
  #
  # @return [Object] the current value of dynamic_scope
  def dynamic_scope; end

  # Sets the attribute dynamic_scope
  #
  # @param value [Object] the value to set the attribute dynamic_scope to.
  # @return [Object] the newly set value
  def dynamic_scope=(_); end

  # Returns the value of attribute instance
  #
  # @return [Object] the current value of instance
  def instance; end

  # Sets the attribute instance
  #
  # @param value [Object] the value to set the attribute instance to.
  # @return [Object] the newly set value
  def instance=(_); end

  # source://json_schemer//lib/json_schemer/schema.rb#5
  def original_instance(instance_location); end

  # Returns the value of attribute short_circuit
  #
  # @return [Object] the current value of short_circuit
  def short_circuit; end

  # Sets the attribute short_circuit
  #
  # @param value [Object] the value to set the attribute short_circuit to.
  # @return [Object] the newly set value
  def short_circuit=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://json_schemer//lib/json_schemer/schema.rb#31
JSONSchemer::Schema::DEFAULT_PROPERTY_DEFAULT_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema.rb#29
JSONSchemer::Schema::ECMA_REGEXP_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema.rb#22
JSONSchemer::Schema::ID_KEYWORD_CLASS = JSONSchemer::Draft202012::Vocab::Core::Id

# source://json_schemer//lib/json_schemer/schema.rb#27
JSONSchemer::Schema::NET_HTTP_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema.rb#24
JSONSchemer::Schema::NOT_KEYWORD_CLASS = JSONSchemer::Draft202012::Vocab::Applicator::Not

# source://json_schemer//lib/json_schemer/schema.rb#25
JSONSchemer::Schema::PROPERTIES_KEYWORD_CLASS = JSONSchemer::Draft202012::Vocab::Applicator::Properties

# source://json_schemer//lib/json_schemer/schema.rb#28
JSONSchemer::Schema::RUBY_REGEXP_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema.rb#20
JSONSchemer::Schema::SCHEMA_KEYWORD_CLASS = JSONSchemer::Draft202012::Vocab::Core::Schema

# source://json_schemer//lib/json_schemer/schema.rb#41
JSONSchemer::Schema::SYMBOL_PROPERTY_DEFAULT_RESOLVER = T.let(T.unsafe(nil), Proc)

# source://json_schemer//lib/json_schemer/schema.rb#23
JSONSchemer::Schema::UNKNOWN_KEYWORD_CLASS = JSONSchemer::Draft202012::Vocab::Core::UnknownKeyword

# source://json_schemer//lib/json_schemer/schema.rb#21
JSONSchemer::Schema::VOCABULARY_KEYWORD_CLASS = JSONSchemer::Draft202012::Vocab::Core::Vocabulary

# source://json_schemer//lib/json_schemer.rb#69
class JSONSchemer::UnknownContentEncoding < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#70
class JSONSchemer::UnknownContentMediaType < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#67
class JSONSchemer::UnknownFormat < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#71
class JSONSchemer::UnknownOutputFormat < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#66
class JSONSchemer::UnknownRef < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#68
class JSONSchemer::UnknownVocabulary < ::StandardError; end

# source://json_schemer//lib/json_schemer.rb#65
class JSONSchemer::UnsupportedOpenAPIVersion < ::StandardError; end

# source://json_schemer//lib/json_schemer/version.rb#3
JSONSchemer::VERSION = T.let(T.unsafe(nil), String)

# source://json_schemer//lib/json_schemer.rb#78
JSONSchemer::VOCABULARIES = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer.rb#102
JSONSchemer::VOCABULARY_ORDER = T.let(T.unsafe(nil), Hash)

# source://json_schemer//lib/json_schemer.rb#104
JSONSchemer::WINDOWS_URI_PATH_REGEX = T.let(T.unsafe(nil), Regexp)

# source://json_schemer//lib/json_schemer/result.rb#7
JSONSchemer::X_ERROR_REGEX = T.let(T.unsafe(nil), Regexp)
